#pragma once
#include "pch.h"

// This was stolen from https://github.com/rdbo/ImGui-DirectX-11-Kiero-Hook and modified to work with my framework and to be more readable

// These comments were generated by GitHub Copilot
#if FRAMEWORK_RENDER_D3D11 // If the rendering API is D3D11 include the D3D11 headers and define the D3D11 hooks

#include <D3D11.h>
#include <DXGI.h>


// Include the necessary header files
#include "../../ImGUI/Styles.h"

// Define function pointers for Present and WndProc
typedef HRESULT(__stdcall* Present) (IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags);
typedef LRESULT(CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

// Declare external function for handling Win32 window messages
extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Declare variables for original Present and WndProc functions
Present oPresent;
WNDPROC oWndProc;

// Declare variables for window, device, context, and render target view
HWND window = NULL;
ID3D11Device* pDevice = NULL;
ID3D11DeviceContext* pContext = NULL;
ID3D11RenderTargetView* mainRenderTargetView;

// Declare a boolean variable to track initialization status
bool hkInit = false;

// Function to initialize ImGui
void InitImGui()
{
	// Create ImGui context
	ImGui::CreateContext();
	ImGuiIO& io = ImGui::GetIO();
	io.ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;

	// Initialize ImGui for Win32 and DirectX 11
	ImGui_ImplWin32_Init(window);
	ImGui_ImplDX11_Init(pDevice, pContext);

	// Setup ImGui style and import fonts
	SetupStyle();
	ImportFonts();
}

// Custom window procedure to handle Win32 window messages
LRESULT __stdcall WndProc(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// Pass window messages to ImGui for handling
	if (ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam))
		return true;

	// If the menu is open, block input to game (except for certain messages)
	if (GUI::bMenuOpen)
	{
		// Block mouse and keyboard input when menu is open
		switch (uMsg)
		{
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_MBUTTONDOWN:
		case WM_MBUTTONUP:
		case WM_MOUSEWHEEL:
		case WM_MOUSEMOVE:
		case WM_KEYDOWN:
		case WM_KEYUP:
		case WM_CHAR:
			return true; // Block these inputs from reaching the game
		}
	}

	// Pass all other messages to the game
	return CallWindowProcA(oWndProc, hWnd, uMsg, wParam, lParam);
}

// Hooked Present function
HRESULT __stdcall hkPresent(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)
{
	// Check if initialization has been performed
	if (!hkInit)
	{
		// Get the device and context from the swap chain
		if (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&pDevice)))
		{
			pDevice->GetImmediateContext(&pContext);

			// Get the window handle and create the render target view
			DXGI_SWAP_CHAIN_DESC sd;
			pSwapChain->GetDesc(&sd);
			window = sd.OutputWindow;
			
			ID3D11Texture2D* pBackBuffer;
			pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);
			if (pBackBuffer != NULL)
			{
				pDevice->CreateRenderTargetView(pBackBuffer, NULL, &mainRenderTargetView);
				pBackBuffer->Release();
			}

			// Hook the window procedure and initialize ImGui
			oWndProc = (WNDPROC)SetWindowLongPtrA(window, GWLP_WNDPROC, (LONG_PTR)WndProc);
			InitImGui();

			// Set initialization flag and call the original Present function
			hkInit = true;
			return oPresent(pSwapChain, SyncInterval, Flags);
		}
		else
			return oPresent(pSwapChain, SyncInterval, Flags);
	}

	// Begin rendering ImGui
	GUI::BeginRender();

	// Push a custom font and render the GUI
	ImGui::PushFont(tahomaFont);
	GUI::Render();
	ImGui::PopFont();

	// End rendering ImGui
	GUI::EndRender();

	// Set the render target and render ImGui draw data
	pContext->OMSetRenderTargets(1, &mainRenderTargetView, NULL);
	ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

	// Check if the cheat should stop running
	if (!Cheat::bShouldRun)
	{
		// Destroy features first (disable their hooks before MH_Uninitialize)
		for (size_t i = 0; i < Features.size(); i++)
		{
			Features[i].get()->Destroy();
		}
		
		// Shutdown ImGui
		ImGui_ImplDX11_Shutdown();
		ImGui_ImplWin32_Shutdown();
		ImGui::DestroyContext();
		
		// Restore original window procedure
		if (oWndProc)
			SetWindowLongPtrA(window, GWLP_WNDPROC, (LONG_PTR)oWndProc);
		
		// Release render target view
		if (mainRenderTargetView)
		{
			mainRenderTargetView->Release();
			mainRenderTargetView = nullptr;
		}
		
		// Release D3D resources
		if (pContext)
		{
			pContext->Release();
			pContext = nullptr;
		}
		if (pDevice)
		{
			pDevice->Release();
			pDevice = nullptr;
		}
		
		// Shutdown kiero (calls MH_Uninitialize)
		kiero::shutdown();
		
		hkInit = false;
		return oPresent(pSwapChain, SyncInterval, Flags);
	}

	// Call the original Present function
	return oPresent(pSwapChain, SyncInterval, Flags);
}

#endif // FRAMEWORK_RENDER_D3D11
